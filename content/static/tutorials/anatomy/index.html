<!--LINK TO DOWNLOAD ALL EXAMPLES-->
<table width="650">
    <tr>
    <td>

    <p class="license">
      If you see any errors in this tutorial or have comments, please <a href="https://github.com/processing/processing-docs/issues?state=open">let us know</a>. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </p>

    <h1 style="line-height: 0.7em;">Anatomy of a Program</h1>
    <h3 style="line-height: 0.7em;"><em>J David Eisenberg</em></h3>

    <p class="txt">&nbsp;</p>

    <p class="txt">
      Many of the tutorials for Processing concentrate on what the language can do (change colors, draw shapes, create arrays of objects) and which function calls will let you accomplish these tasks. These are things you need to know in order to write a program in Processing.
    </p>

    <p class="txt">
      There&rsquo;s one piece of the puzzle that these tutorials don&rsquo;t address: how do you analyze a problem and break it down into steps that the computer can do? In this
      tutorial, I&rsquo;m going to show you what went through my head as I took on the task of writing functions to draw regular polygons and star-shaped figures in Processing. This is a good choice because the task is not too big to get your mind around, but it&rsquo;s not an entirely trivial problem, either.  
    </p>

    <p class="txt">
      Remember that what you are seeing here is my particular thought process and programming style. There are many different approaches and styles. As you continue programming, you will find your own. You can also see other people&rsquo;s programming stye (though not their thought process!) by looking at the source code for the programs at <a href="http://openprocessing.org/">openProcessing.org</a>.
    </p>



    <h3>Drawing Regular Polygons</h3>

    <p class="txt">
      You wouldn&rsquo;t think of building a house without a blueprint, and you shouldn&rsquo;t think of writing a program without a plan of some sort. Since Processing is such a visual language, I always have to sketch out what I want as a result before I approach the keyboard. So that&rsquo;s where I started.
    </p>



    <h3>Step 1: Planning on paper</h3>

    <p class="txt">
      The first step was to draw a crude diagram to dredge up old memories of how regular polygons work. The hexagon was the first one I drew. As you can see from the little loop I drew inside the hexagon, the center angles of all the slices add up to a complete circle, or 360&deg;, and the &ldquo;radius&rdquo; of the polygon is a line from the center to each vertex. The angle between each of the radius lines is thus 360&deg; divided by the number of sides.
    </p>


    <img src="imgs/sketch1.jpg" alt="Crude diagram of regular polygons with 3-6 sides" width="400" height="120" class="tut" />

    <p class="txt">
      I just needed to get an idea of what the task was, and a hand-drawn diagram did the job. I didn&rsquo;t need to generate the diagram in a drawing program.
    </p>

    <blockquote>
      <p class="txt">Programming Hint: When you do your planning, do it away from the computer. If you are sitting in front of the computer, the screen will whisper, &ldquo;Look at me! Look at me!&rdquo; and the keyboard will whisper &ldquo;Type something! Type something!&rdquo; Go to your kitchen table instead.
    </p>
    </blockquote>



      <h3>Step 2: Some basic trigonometry</h3>

    <p class="txt">
      So, if you have a line of length <em>r</em> starting at (0,0) at an angle theta (&theta;), what are its coordinates in terms of <em>x</em> and <em>y</em>? If you know a little bit of
      trigonometry, the answer is that the endpoint of the line is at (<em>r</em>&nbsp;cos&nbsp;&theta;,&nbsp;<em>r</em>&nbsp;sin&nbsp;&theta;). If you don&rsquo;t
      know trigonometry, take a look at <a href="http://catcode.com/trig/">this tutorial</a> (a general and very light introduction to
      trigonometry), <a href="http://processing.org/learning/trig/">this tutorial</a> (oriented towards Processing), and <a href="http://learningprocessing.com/examples/chp13/example-13-05-polar-cartesian">this example from chapter 13 of <em>Learning Processing</em></a>. In the following diagram, angles are drawn clockwise, which is how they are measured in Processing.
    </p>

    <img src="imgs/sketch2.jpg" alt="Diagram of angle showing relationship of cosine and sine" width="250" height="164" class="tut" />



    <h3>Step 3: Design Decisions</h3>

    <p class="txt">
      It looks like this is a job for a <code>for</code> loop that runs from 0 to <em>n</em> (the number of sides), calculating the points for each vertex and drawing lines connecting them. At each step, the angle at which we draw is increased by 360&deg;/<em>n</em>.
    </p>

    <p class="txt">
      The problem with drawing a group of lines is that they are just lines&mdash;you don&rsquo;t get a true shape that you can fill, like <code>rect()</code> or <code>triangle()</code>. Luckily, Processing lets you create your own shapes with the <a href="http://processing.org/reference/beginShape_.html"><code>beginShape()</code></a>, <a href="file:///home/david/processing-1.0.9/reference/vertex_.html"><code>vertex()</code></a>, and <a href="http://processing.org/reference/endShape_.html"><code>endShape()</code></a> functions. The first example on the reference page for <code>beginShape()</code> is the model to follow. So the next design decision is to make polygons as true shapes.</p>

    <p class="txt">
      Since you probably want to draw many polygons during a program, it makes sense to have a <code>polygon()</code> function. What parameters does it need? Four come to mind: the number of sides, the center <em>x</em> and <em>y</em> coordinate, and the radius.  Here&rsquo;s the code. I wrote several different calls to <code>polygon()</code> in the <code>setup()</code> function. Although I calculated <code>angle</code> in degrees, sine and cosine measure angles in radians, so I had to use the <code>radians()</code> function to do a conversion.
    </p>


    <img src="imgs/polytest1.jpg" alt="polygon tests"width="200" height="200" class="tut" />

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;polygon(3,&nbsp;50,&nbsp;75,&nbsp;50);
&nbsp;&nbsp;polygon(4,&nbsp;170,&nbsp;75,&nbsp;50);

&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255, 204, 255);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128, 0, 128);
&nbsp;&nbsp;polygon(5,&nbsp;50,&nbsp;180,&nbsp;50);

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(0);
&nbsp;&nbsp;polygon(6,&nbsp;170,&nbsp;180,&nbsp;50);
}

<span style="color: #33997E;">void</span> polygon(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r) {
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = 360.0 / n;

&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; n; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + r * <span style="color: #006699;">cos</span>(<span style="color: #006699;">radians</span>(angle * i)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;r&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(<span style="color: #006699;">radians</span>(angle * i)));
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
}
</pre>


    <h3>Two Steps Forward, One Step Back</h3>

    <p class="txt">
      The program works, so it&rsquo;s time to see if there are things that could be added or changed.  First, the triangle and pentagon seem somehow wrong; they are usually drawn pointing upwards instead of to the side. The reason they look odd is that the first vertex (at 0&deg;) points to the right instead of straight up. It would be nice to have an extra parameter that gives the starting angle for the first vertex. (Another solution is to leave things as they are and let programmers use <code>rotate()</code> [<a href="http://processing.org/learning/transform2d">see this tutorial</a>], but I made the design decision to use an extra parameter.) Should the angle be given in degrees or in radians? The answer: radians, in order to be consistent with everything else that Processing does.
    </p>

    <p class="txt">
      My next thought was that it would be nice to be able to specify a width and height for the polygon, much as you do with an <code>ellipse()</code> or <code>rectangle()</code>. I already knew what the formula would be, but I wanted to make a drawing to check it out. As a preliminary experiment, I tried drawing a pentagon into a square using a protractor and straightedge, and ended up with the awful drawing at the left. How come the sides weren&rsquo;t equal length? I realized that I was trying to make the drawing fit my preconceptions, rather than making an accurate drawing and seeing where that led me. The drawing on the right was done much more carefully. After a little thinking, I realized that the pentagon wouldn&rsquo;t fit the square exactly, because the angles weren&rsquo;t multiples of 90 degrees. The regular polygon fits in a <em>circle</em>, not in a square!
    </p>

    <div style="text-align:center;">
      <img src="imgs/bad_pentagon.jpg" alt="pentagon with unequal sides" width="200" height="200" style="display: inline;" class="tut" />
      <img src="imgs/accurate_pentagon.jpg" alt="pentagon with equal sides" width="210" height="200" style="display: inline;" class="tut" />
    </div>

    <p class="txt">
      Well, that was a dead end. That sort of thing happens in programming all the time, so I didn&rsquo;t spend too much time worrying about it. It was time for another approach. Since I didn't have an accurate way of drawing ellipses, I had to think about the problem a different way. Presume you have a circle drawn on a square sheet of rubber, and you stretch it out so that it&rsquo;s twice as wide but the same height. The vertical position of the points on the circle does not change, but the horizontal positions are now twice as far away from the center as they used to be. The same idea applies if you stretch the sheet vertically. The following crude drawings seemed to bear this out, so it was time to rewrite the <code>polygon()</code> function.
    </p>

    <p style="text-align:center;">
      <img src="imgs/stretchy.jpg" alt="diagrams showing stretched circle" width="600" height="194" class="tut" />
    </p>

    <img src="imgs/poly2.png" alt="more complex polygon tests" width="200" height="229" class="tut" />

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;polygon(3,&nbsp;50,&nbsp;75,&nbsp;100,&nbsp;100,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0); <span style="color: #666666;">// -90 degrees</span>
&nbsp;&nbsp;polygon(4,&nbsp;170,&nbsp;75,&nbsp;50,&nbsp;125,&nbsp;-<span style="color: #718A62;">PI</span> / 4.0); <span style="color: #666666;">// -45 degrees</span>

&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255, 204, 255);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128, 0, 128);
&nbsp;&nbsp;polygon(5,&nbsp;50,&nbsp;200,&nbsp;75,&nbsp;50,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0); <span style="color: #666666;">// -90 degrees</span>

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(0);
&nbsp;&nbsp;polygon(6,&nbsp;170,&nbsp;200,&nbsp;50,&nbsp;100,&nbsp;0);

&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128);
&nbsp;&nbsp;<span style="color: #666666;">// Draw enclosing ellipses to make sure we did it right</span>
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(50, 75, 100, 100);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 75, 50, 125);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(50, 200, 75, 50);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 200, 50, 100);
}

<span style="color: #33997E;">void</span> polygon(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> w, <span style="color: #E2661A;">float</span> h, <span style="color: #E2661A;">float</span> startAngle) {
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = <span style="color: #718A62;">TWO_PI</span>/ n;

&nbsp;&nbsp;<span style="color: #666666;">// The horizontal &quot;radius&quot; is one half the width,</span>
&nbsp;&nbsp;<span style="color: #666666;">// the vertical &quot;radius&quot; is one half the height</span>
&nbsp;&nbsp;w&nbsp;=&nbsp;w&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;h&nbsp;=&nbsp;h&nbsp;/&nbsp;2.0;

&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; n; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + w * <span style="color: #006699;">cos</span>(startAngle + angle * i), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;h&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(startAngle + angle * i));
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
}
</pre>

    <p class="txt">
      Since everything was in radians, I now described angles in terms of <code>PI</code> and <code>TWO_PI</code> (2&pi;), since 2&pi; radians equals 360&deg;. In addition to the code in <code>setup()</code> to test the new features, I drew ellipses with the same center and width and height as the polygons to make sure that the vertices were within the proper area.
    </p>




    <h3>Too Many Parameters</h3>

    <p class="txt">
      I now had a much more flexible function for drawing polygons, but it came at the expense of more parameters. It would be nice to be able to draw the ordinary case (equal width and height, start angle of zero) without having to specify all those parameters. The solution is to <dfn>overload</dfn> the function. In Processing, you can have two functions with the same name, as long as they have different numbers of parameters and/or types of parameters. An example of this is Processing&rsquo;s <code>stroke()</code> function, which is overloaded so that you can call it with one number for grayscale, three numbers for color, or four numbers for color with opacity. Processing looks at the number of arguments you provide and figures out which version of <code>stroke()</code> to call.
    </p>

    <p class="txt">
      Here is the code to add to the previous example. When you give <code>polygon()</code> only four numbers, it will call the following function, which calls the &ldquo;big&rdquo; version of the function with width and height equal to twice your desired radius, and a start angle of zero.
    </p>

<pre>
<span style="color: #33997E;">void</span> polygon(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r) {
&nbsp;&nbsp;polygon(n,&nbsp;cx,&nbsp;cy,&nbsp;r&nbsp;*&nbsp;2.0,&nbsp;r&nbsp;*&nbsp;2.0,&nbsp;0.0);
}
</pre>

    <p class="txt">
      And here is some code to test the overloaded function.
    </p>

    <img src="imgs/poly3.png" alt="regular triangle and diamond using overloaded functions" width="214" height="169" class="tut" />

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);
&nbsp;&nbsp;<span style="color: #006699;">smooth</span>();
&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;polygon(3,&nbsp;70,&nbsp;75,&nbsp;50);&nbsp;<span style="color: #666666;">// use the defaults</span>
&nbsp;&nbsp;polygon(4,&nbsp;170,&nbsp;75,&nbsp;25);
&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128);
&nbsp;&nbsp;<span style="color: #666666;">// draw enclosing ellipses to make sure we did it right</span>
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(70, 75, 100, 100);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 75, 50, 50);
}
</pre>



    <h3>Safe Computing</h3>
    
    <p class="txt">
      What happens if someone tries to draw a polygon with 2 sides, 1 side, or worse, 0 sides?  The first two will generate a line and a point, but the third one will cause a division by zero error when trying to figure out the angle. And what would happen with negative numbers? Since polygons with fewer than three sides don&rsquo;t make a lot of sense, I wrapped the body of the <code>polygon()</code> function inside of an <code>if</code> statement. Now, when someone specifies two or fewer sides, the function just won&rsquo;t draw anything.
    </p>

<pre>
void polygon(int n, float cx, float cy, float w, float h, float startAngle) {
  if (n &gt; 2) {
    float angle = TWO_PI/ n;
    .
    .
    beginShape()
    .
    .
    endShape(CLOSE);
  }
}
</pre>


    <h3>Drawing Stars</h3>

    <p class="txt">
      Now that I was satisfied with the <code>polygon()</code> function, it was time to move on to drawing stars. From some playing around with a crude sketch, I figured that it would be possible to draw a star by figuring out where all the diagonals of a polygon intersect.
    </p>

    <div class="text-align:center;">
      <img src="imgs/bad_stars.jpg" width="450" height="204" alt="Stars drawn by intersections of diagonals" class="tut" />
    </div>

    <p class="txt">
      I saw two problems here. First, finding the intersection point of two lines is
a lot of calculation. Not particularly hard calculation, but a lot of it,
and it gets tricky when you have vertical lines.
Second, I couldn't have a four-sided or three-sided
arrow shape; there weren&rsquo;t enough diagonals.
    </p>

    <p class="txt">
      Then, I had another idea. I can&rsquo;t tell you where the idea came from or how I arrived at it; it just hit me. That&rsquo;s a part of the process that I don&rsquo;t think can be taught. Here was the idea: What if you had a polygon cut out of cookie dough and you sort of pushed in the sides to make a star shape? That is a method that works for squares and triangles.
    </p>

    <div class="text-align:center;">
      <img src="imgs/cookie_stars.jpg" width="450" height="128" alt="Stars drawn by pushing in the sides" class="tut" />
    </div>

    <p class="txt">
      When you push in the sides, you push them in at the midpoint so that you get a nice symmetric cookie. From there, it wasn&rsquo;t a big leap to figure out: &ldquo;what if I had a shorter radius at half of every slice of the polygon?&rdquo; 
    </p>

    <div class="text-align:center;">
      <img src="imgs/good_stars.jpg" width="450" height="114" alt="Stars drawn by pushing in the sides" class="tut" />
    </div>

    <p class="txt">
      This code would be fairly easy to write. I would need one extra parameter: the proportion of the small radius to the big radius. In the following code, an <code>if</code> statement controls whether to use the short radius or the long radius. I also put in an overloaded version that draws a star with equal width and height and a start angle of zero. For the test, I made the short radius one half the long radius.
    </p>

    <img src="imgs/surprise.png" width="200" height="226" alt="3, 4, 5, and 6-sided stars" class="tut" />

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);
&nbsp;&nbsp;<span style="color: #006699;">smooth</span>();

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;star(3,&nbsp;60,&nbsp;75,&nbsp;100,&nbsp;100,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0, 0.50); <span style="color: #666666;">// -90 degrees</span>
&nbsp;&nbsp;star(4,&nbsp;170,&nbsp;75,&nbsp;25,&nbsp;0.50);&nbsp;&nbsp;<span style="color: #666666;">// use simpler call</span>

&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255, 204, 255);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128, 0, 128);
&nbsp;&nbsp;star(5,&nbsp;60,&nbsp;200,&nbsp;75,&nbsp;50,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0, 0.50); <span style="color: #666666;">// -90 degrees</span>

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(0);
&nbsp;&nbsp;star(6,&nbsp;170,&nbsp;200,&nbsp;50,&nbsp;100,&nbsp;0,&nbsp;0.50);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128);
&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #666666;">// draw enclosing ellipses to make sure we did it right</span>
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(60, 75, 100, 100);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 75, 50, 50);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(60, 200, 75, 50);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 200, 50, 100);
}

<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r, <span style="color: #E2661A;">float</span> proportion) {
&nbsp;&nbsp;star(n,&nbsp;cx,&nbsp;cy,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;0.0,&nbsp;proportion);
}

<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> w, <span style="color: #E2661A;">float</span> h,
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> startAngle, <span style="color: #E2661A;">float</span> proportion) {

&nbsp;&nbsp;<span style="color: #669900;">if</span> (n &gt; 2) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = <span style="color: #718A62;">TWO_PI</span>/ (2 *n);  <span style="color: #666666;">// twice as many sides</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dw; <span style="color: #666666;">// draw width</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dh; <span style="color: #666666;">// draw height</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;w&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;h&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; 2 * n; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">if</span> (i % 2 == 1) { <span style="color: #666666;">// for odd vertices, use short radius</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + dw * <span style="color: #006699;">cos</span>(startAngle + angle * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;dh&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(startAngle + angle * i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
&nbsp;&nbsp;}
}
</pre>



    <h3>What Went Wrong?</h3>
    
    <p class="txt">
      When I ran this program, I just freaked out. Everything looked great, except for the three-sided star. How come I didn&rsquo;t get a star from it?  The code sure looks correct, so I decided to see what would happen if I drew the diagram by hand. I measured the angles with my protractor, and I drew the long radius lines with a length of two inches in black and the short radius lines with a length of one inch in red. Sure enough, it just so happens that the endpoints of the short radius lines are right on the lines of the main triangle. The program <em>is</em> drawing a star, with the sides pushed in by zero.
    </p>

    <div style="text-align:center;">
        <img src="imgs/triangle_star.jpg" width="200" height="178" alt="triangular star drawn by hand" class="tut" />
    </div>

    <p class="txt">
      While wondering why this happened, I remembered that the cosine of the angle between the lines, 60&deg; (&pi;/3) comes out to 0.5, and I strongly suspected that this had something to do with it. To test my hypothesis, I changed the square to use a proportion of cosine of 45&deg; (&pi;/4), the pentagon to cosine of 36&deg; (&pi;/5), and the hexagon to cosine of 30&deg; (&pi;/6). Sure enough, they all came out with no push-in.
    </p>

    <p class="txt">
      So, if you are drawing a star with <i>n</i> sides and you set the proportion for the short radius to long radius to the cos(&pi;/<i>n</i>), you get a non-star star! I still can&rsquo;t write a mathematical proof of it, but it is an interesting result. I don&rsquo;t consider that side trip of writing the test program to be wasted time; I did learn something new and mildly interesting, and it may turn out to be useful in the future.
    </p>


    <blockquote>
      <p class="txt">
      <b>Programming Challenge:</b> What happens if you set the
      proportion to something <em>greater</em> than the &ldquo;non-star&rdquo;
      ratio? Try it and find out.
      </p>
    </blockquote>


    <p class="txt">
      Of course, the way to get a three-sided star is to set the proportion
      to an amount less than 0.5, which I did in the following setup code,
      with much better results. I also changed the proportions for the other
      stars just to see what they would look like.
    </p>

<img src="imgs/better_stars.png" width="200" height="228" alt="3, 4, 5, and 6-sided stars" class="tut"/>

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>(){
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;star(3,&nbsp;60,&nbsp;75,&nbsp;100,&nbsp;100,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0, 0.3); <span style="color: #666666;">// -90 degrees</span>
&nbsp;&nbsp;star(4,&nbsp;170,&nbsp;75,&nbsp;25,&nbsp;0.5);&nbsp;&nbsp;<span style="color: #666666;">// use simpler call</span>

&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255, 204, 255);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128, 0, 128);
&nbsp;&nbsp;star(5,&nbsp;60,&nbsp;200,&nbsp;75,&nbsp;50,&nbsp;-<span style="color: #718A62;">PI</span> / 2.0, 0.75); <span style="color: #666666;">// -90 degrees</span>

&nbsp;&nbsp;<span style="color: #006699;">noFill</span>();
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(0);
&nbsp;&nbsp;star(6,&nbsp;170,&nbsp;200,&nbsp;50,&nbsp;100,&nbsp;0,&nbsp;0.4);
&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(128);
&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #666666;">// Draw enclosing ellipses to make sure we did it right</span>
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(60, 75, 100, 100);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 75, 50, 50);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(60, 200, 75, 50);
&nbsp;&nbsp;<span style="color: #006699;">ellipse</span>(170, 200, 50, 100);
}


<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r, <span style="color: #E2661A;">float</span> proportion) {
&nbsp;&nbsp;star(n,&nbsp;cx,&nbsp;cy,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;0.0,&nbsp;proportion);
}

<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> w, <span style="color: #E2661A;">float</span> h,
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> startAngle, <span style="color: #E2661A;">float</span> proportion) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #669900;">if</span> (n &gt; 2) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = <span style="color: #718A62;">TWO_PI</span>/ (2 *n);  <span style="color: #666666;">// twice as many sides</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dw; <span style="color: #666666;">// draw width</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dh; <span style="color: #666666;">// draw height</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;w&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;h&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; 2 * n; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">if</span> (i % 2 == 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + dw * <span style="color: #006699;">cos</span>(startAngle + angle * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;dh&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(startAngle + angle * i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
&nbsp;&nbsp;}
}
</pre>

    <h3>Using the Functions</h3>
    <p class="txt">
      Finally, in order to use the functions in something other than a test, I decided to write a program that would randomly generate polygons and stars. The window is 300 by 300, and the stars or polygons have a radius of 24 dots, so I have six rows and five columns (the extra dot is for spacing). Remember how I said that knowing the proportions that would create a star &ldquo;may turn out to be useful in the future&rdquo;? Well, they aren&rsquo;t just useful for this program&mdash;they&rsquo;re vital. When I generate a star, I need to make sure it really has a star shape, so I have to keep the proportion of short to long radius less than the cosine of &pi; divided by the number of sides.
    </p>

    <p class="txt">
      Here is the code for <code>setup()</code> and <code>draw()</code>:
    </p>

<img src="imgs/randomness.png" alt="random polygons and stars" width="200" height="213" class="tut" />

<pre>
<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>setup</b></span>() {
&nbsp;&nbsp;<span style="color: #006699;">size</span>(300, 300);
&nbsp;&nbsp;<span style="color: #006699;">background</span>(255);
&nbsp;&nbsp;<span style="color: #006699;">frameRate</span>(6);
&nbsp;&nbsp;<span style="color: #006699;">rectMode</span>(<span style="color: #718A62;">CENTER</span>);
}

<span style="color: #33997E;">void</span> <span style="color: #006699;"><b>draw</b></span>() {
&nbsp;&nbsp;<span style="color: #666666;">// Choose a random stroke color</span>
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> r = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 255));
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> g = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 255));
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> b = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 255));
&nbsp;&nbsp;<span style="color: #666666;">// Fill opacity</span>
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> opacity = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(100, 255));
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> nSides = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(3, 9));

&nbsp;&nbsp;<span style="color: #666666;">// Determine the center x and y coordinates</span>
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> cx = 25 + 50 * <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 6));
&nbsp;&nbsp;<span style="color: #E2661A;">int</span> cy = 25 + 50 * <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(0, 6));

&nbsp;&nbsp;<span style="color: #666666;">// If a random number (0 or 1) is 0, draw a polygon;</span>
&nbsp;&nbsp;<span style="color: #666666;">// otherwise, draw a star</span>
&nbsp;&nbsp;<span style="color: #E2661A;">boolean</span> isPolygon = <span style="color: #006699;">int</span>(<span style="color: #006699;">random</span>(2)) == 0;

&nbsp;&nbsp;<span style="color: #666666;">// For stars, you need the proportion of short to long radius</span>
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> proportion;

&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(255); <span style="color: #666666;">// erase any previous drawing in this area</span>
&nbsp;&nbsp;<span style="color: #006699;">fill</span>(255);
&nbsp;&nbsp;<span style="color: #006699;">rect</span>(cx, cy, 50, 50); 

&nbsp;&nbsp;<span style="color: #006699;">stroke</span>(r, g, b);
&nbsp;&nbsp;<span style="color: #006699;">fill</span>(r, g, b, opacity);
&nbsp;&nbsp;<span style="color: #669900;">if</span> (isPolygon) {
&nbsp;&nbsp;&nbsp;&nbsp;polygon(nSides,&nbsp;cx,&nbsp;cy,&nbsp;24);
&nbsp;&nbsp;}&nbsp;<span style="color: #669900;">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;proportion&nbsp;=&nbsp;<span style="color: #006699;">random</span>(0.2, 0.8) * <span style="color: #006699;">cos</span>(<span style="color: #718A62;">PI</span> / nSides);
&nbsp;&nbsp;&nbsp;&nbsp;star(nSides,&nbsp;cx,&nbsp;cy,&nbsp;24,&nbsp;proportion);
&nbsp;&nbsp;}
}

<span style="color: #33997E;">void</span> polygon(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r) {
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = 360.0 / n;
&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; n; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + r * <span style="color: #006699;">cos</span>(<span style="color: #006699;">radians</span>(angle * i)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;r&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(<span style="color: #006699;">radians</span>(angle * i)));
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
}

<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> r, <span style="color: #E2661A;">float</span> proportion) {
&nbsp;&nbsp;star(n,&nbsp;cx,&nbsp;cy,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;2.0&nbsp;*&nbsp;r,&nbsp;0.0,&nbsp;proportion);
}

<span style="color: #33997E;">void</span> star(<span style="color: #E2661A;">int</span> n, <span style="color: #E2661A;">float</span> cx, <span style="color: #E2661A;">float</span> cy, <span style="color: #E2661A;">float</span> w, <span style="color: #E2661A;">float</span> h,
&nbsp;&nbsp;<span style="color: #E2661A;">float</span> startAngle, <span style="color: #E2661A;">float</span> proportion) {
&nbsp;&nbsp;<span style="color: #669900;">if</span> (n &gt; 2) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> angle = <span style="color: #718A62;">TWO_PI</span>/ (2 *n);  <span style="color: #666666;">// twice as many sides</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dw; <span style="color: #666666;">// draw width</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #E2661A;">float</span> dh; <span style="color: #666666;">// draw height</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;w&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;h&nbsp;/&nbsp;2.0;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">beginShape</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">for</span> (<span style="color: #E2661A;">int</span> i = 0; i &lt; 2 * n; i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #669900;">if</span> (i % 2 == 1) <span style="color: #666666;">// for odd vertices, use short radius</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw&nbsp;=&nbsp;w&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;=&nbsp;h&nbsp;*&nbsp;proportion;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">vertex</span>(cx + dw * <span style="color: #006699;">cos</span>(startAngle + angle * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cy&nbsp;+&nbsp;dh&nbsp;*&nbsp;<span style="color: #006699;">sin</span>(startAngle + angle * i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #006699;">endShape</span>(<span style="color: #718A62;">CLOSE</span>);
&nbsp;&nbsp;}
}
</pre>

<h3>Polygons and Stars as Objects</h3>
<p class="txt">
Now that I have working functions for polygons and stars, it might
be useful to make a <code>Polygon</code> and <code>Star</code> class
so that I can treat them as objects. The method I would use is much
the same; I would start with simple test cases, build up the
classes step by step, and finally use them in a full-blown program.
<a href="http://processing.org/learning/objects">Here is
a tutorial about objects in Processing.</a>
</p>

<h3>Summing Up</h3>
<p class="txt">
This tutorial has shown you the things you never see in books.
In a book, all the diagrams are
picture perfect. You see a sample program, and it just works, and
it produces gorgeous results. To be fair, the authors
<em>can&rsquo;t</em> show you their thought process; otherwise,
their books would be ten times as large. In fact, I did not include
all the versions where a misplaced parenthesis or a forgotten call
to <code>radians()</code> made my sketch explode into a mass of
incomprehensible lines. But all of us, the big name authors, the
people who write these tutorials, and the beginning programmers,
go through this same tawdry process of design, trial and error,
and development. I wanted you to see that process at least once,
because we are all in this together.
</p>

<p class="txt">
You can <a href="code/polystar.zip">download the files from this tutorial</a>.
</p>

  </td>
  </tr>
</table>
